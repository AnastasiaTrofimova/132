| Номер задания | Процесс выполнения |
|1 | |
|2 |+|
|3 | |
|4 | |
|5 |+|
|6 |+|
|7 |+|
|8 |+|
|9 | |
|10 | |
|11 | |
|12 |+|
|13 | |
|14 |+|
|15 | |
|16 | |
|17 |+|
|18 |+|
|19 |+|
|20 |+|
|21 |+|
|22 | |
|23 |+|
|24 |+|
|25 |+|
|26 |+|
|27 |+|


Стратегия решения 5:
1. Организовать цикл перебора чисел
2. Перевод числа в 2-ю СС (bin , f'{n:b}')
3. Выполнение условий задачи с дописью и заменой.
4. Перевод в int и проверка на условие
5. После вывода минимального, прерывание break

Задание 6 с черепашкой:
1. Вспомнить команды черепашки
2.Воспроизвести алгоритм задачи
3. Расставить сами точки внутри контура
4. Вручную посчитать точки
(жирность точек не влияет на подсчет)
forward()-движение впередж; аргумент- количество пикселей 
left(), right()-поворот, в скобках градус поворота 
pu()- поднять перо 
goto()- идти на позицю (x,y)
dot()- поставить точку; ()-толщина точки
done()- закончить рисование 

Задание 8:
1. Сгенирировать все возможные варианты чисел 
2. Рассматриваем каждое число (строку) на удовлетворение условиям задачи (count(), index())
3. Выводим счетчик правильных занчений, если число прозодит по всем проверкам, пишем количество таких чисел


Задание 19-21:
строим табоицу 

Для решения 2 задачи нужно перебрать все возможные значения комбинаций: организовать влженные циклы, количества переменных и проверить выражения по условию, особое внимание нужно уделить скобкам и порядку операций. 
импликация (<=) стрелочка 
или (or)галочка вниз
не (not) *приставка*
и (and) галочка вверх

1) print() вывести значения (текст) на экран
print('x y z w') print(f'сумма={x}')
2) for x in range (1,100,2) цикл с перебором от 1 до 100 с шагом в 2 позволяет проводить итерации — реализовывать набор инструкций нужное количество раз
 for x in s перебор значений в писке s
3) num = int ('10101', 2) перевод из двоичной сиситемы счисления в десятичную 
4) str(12)  число в строку 
5) if оператор если
if (not(y<=x) or (z<=w) or not(z))==False  все в if проверяется на правду 
 if not sp:  sp пустой список, есои список неправда 
 else иначе
 elif другое условие 
6) readline() считывает строку из стандартного входного потока
7) with open  Эта функция служит для открытия файла и последующей работы с ним. Открывает файл для записи и чтения. Перезаписывает существующий файл, если файл существует. Если файл не существует, создается новый файл для чтения и записи.
8) import () подключение пакетов и модулей осуществляется с помощью import. Это позволяет распределять код по логическим "узлам" приложения(модели данных, обработчики, и тп.), что позволяет получить менее нагруженные кодом файлы
9) max() возвращает наибольшее значение элемента итерируемого объекта или самое большое из двух или более переданных позиционных аргументов. Если указан один позиционный аргумент, он должен быть итерируемым объектом (список, кортеж, словарь и т. д.).
10)  min() возвращает минимальное значение элемента из итерируемого объекта или наименьшее из двух или более переданных позиционных аргументов. Если указан один позиционный аргумент, он должен быть итерируемым объектом (список, кортеж, словарь и т.д.)
Эти функции выдают минимальное и максимальное число из набора соответственно.
11) return () возвращение функции
12) def определяете функцию
13) dot (2) точка жирность 2 
14) goto (x*30,y*30) идти в точку с коэф увеличения
15) up() вверх
16) down ( ) вниз
from turtle import * использование программы
17) right(300) направо на 300 градусов  
18) not отрицание, oн превращает правду в ложь, а ложь в правду. Унарный он потому, что применяется к одному выражению, стоящему после него
19) list.append() добавляет значение в конец списка.
20) input() Эта функция запрашивает у пользователя ввод, ждёт нажатия клавиши Enter, а затем возвращает набранный текст.
21) len(my_list) подсчет элементов списка или кличесво символов в строке
22) Float() конвертация стироки в число
23) list() составить список из итераций цикла
24) tuple() кортеж, это те же списки за одним исключением.
25) range () диапозон чисел 
26) enumerate () Если нужно в цикле посчитать количество элементов (по одному элементу за раз)
27) any() возвращает True , если какой-либо (любой) элемент в итерируемом объекте логическое значение или 
28) all()возвращает значение True , если все элементы в итерируемом объекте - истинны, в противном случае она возвращает значение False . if all (a) если все значения а правда if all(((x%2==0) <= (x%3!=0)) or (x+a>=100) for x in range(1,1000)) все значения меняются 
Эти функции могут быть использованы в паре с генератор-выражениями, чтобы определить соответствие элементов заданному условию.
29) next() данная функция возвращает следующий элемент в итераторе.
30) break прерывание цикла 
31) continue  используется в циклах для пропуска итерации в цикле и переходе к след шагу 
32) nums=prodact('is' repeat=10) 10- кол-во знаков  is- символы из  хот строк nums- список со всеми возможными значениями мленькие списки.
33) set() создает множество неповторяющихся значений списка
34) repeat () создает итератор, который возвращает объект снова и снова
35) sorted () cортируетэлементы списка по возрастанию
36) sum () возвращает сумму множества чисел
37) import () подключение пакетов и модулей
38) while (“пока”) позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно
39) Модуль itertools стандартизирует основной набор быстрых эффективных по памяти инструментов, которые полезны сами по себе или в связке с другими инструментами. алшебраический итератор 
40) nested() вложить 
41) <=  импликация- стрелочка 
42) num=(bin(i)[2:])   вместо i можно написать конктретное число, для перевода в двоичную систему (сс), и и гнорируем первые два знака, получаем строчку 
42) num.count('1') метод подсчета единиц в строке num 
43)n = 10 % 2 нахождение остатка 
45) pass  ничего не делать, как заглушка 
44)m = 10//2 нахождение целой части числа
45) s.index('6') возвращает номер элемента 
46) nn=n.split() разбивает строчку по символу разделителю либо пробелу 
47) len(s) возвращает длину списка 
48) n=''.join(s) был список и мы получаем все символы в строчку разделяя или не разделяя их чем-то 
 s =[]  создать пустой список 
 s = [0] вызов первого эжлемента списка  
 
 
 
 
 
 
 27:
 with open('27_A.txt') as f:
    n=[ x for x in f ]
n.pop(0)
sp = []
for i in n:
    sp.append (list(map(int, i.split())))
k =[]
for i in range (len(sp)):
    if sp [i][1] % 36==0:
       k.append(sp [i][1]//36)
    else:
        k.append((sp [i][1]//36)+1)
ind=[]        
for i in range (len(sp)):
    ind.append(sp [i][0])
sp=list(zip(ind,k))
        
print (sp)
